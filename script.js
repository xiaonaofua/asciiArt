// Â§öËØ≠Ë®ÄÊîØÊåÅ
class I18n {
    constructor() {
        this.currentLang = localStorage.getItem('preferred-language') || 'zh';
        this.translations = {
            zh: {
                title: 'üé® Êô∫ËÉΩASCIIËâ∫ÊúØ',
                subtitle: 'Êô∫ËÉΩASCIIËâ∫ÊúØÁîüÊàêÂô® - ÊîØÊåÅÊñáÂ≠óËØÜÂà´‰∏éÂõæÂÉèËΩÆÂªì',
                upload_title: 'ÈÄâÊã©ÊàñÊãñÊãΩÂõæÁâá',
                upload_desc: 'ÊîØÊåÅPNG„ÄÅJPEGÊ†ºÂºè',
                select_image: 'ÈÄâÊã©ÂõæÁâá',
                preview_title: 'ÂéüÂõæÈ¢ÑËßà',
                ascii_width: 'ASCIIÂÆΩÂ∫¶:',
                edge_sensitivity: 'ËæπÁºòÊïèÊÑüÂ∫¶:',
                noise_filter: 'Âô™Èü≥ËøáÊª§:',
                invert_colors: 'ÂèçËΩ¨È¢úËâ≤',
                enable_ocr: 'ÂêØÁî®ÊñáÂ≠óËØÜÂà´ (OCR)',
                auto_optimize: 'Ëá™Âä®‰ºòÂåñÂèÇÊï∞',
                convert_button: 'üéØ Êô∫ËÉΩËΩ¨Êç¢ASCII',
                processing: 'Ê≠£Âú®Â§ÑÁêÜÂõæÁâá...',
                result_title: 'ASCIIËâ∫ÊúØÁªìÊûú',
                copy_result: 'üìã Â§çÂà∂ÁªìÊûú',
                download_txt: 'üíæ ‰∏ãËΩΩtxt',
                reset: 'üîÑ ÈáçÊñ∞ÂºÄÂßã',
                footer: 'Êô∫ËÉΩASCIIËâ∫ÊúØÁîüÊàêÂô® - ÊîØÊåÅÊñáÂ≠óËØÜÂà´‰∏éÂõæÂÉèËΩÆÂªì | Á∫ØÂâçÁ´ØÂÆûÁé∞',
                analyzing_image: 'Ê≠£Âú®ÂàÜÊûêÂõæÂÉèÁâπÂæÅ...',
                recognizing_text: 'Ê≠£Âú®ËØÜÂà´ÊñáÂ≠ó...',
                generating_ascii: 'Ê≠£Âú®ÁîüÊàêASCIIËâ∫ÊúØ...',
                copy_success: '‚úÖ Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø',
                copy_failed: 'Â§çÂà∂Â§±Ë¥•ÔºåËØ∑ÊâãÂä®ÈÄâÊã©ÊñáÊú¨Â§çÂà∂',
                invalid_file: 'ËØ∑ÈÄâÊã©ÊúâÊïàÁöÑPNGÊàñJPEGÂõæÁâáÊñá‰ª∂ÔºÅ',
                conversion_error: 'ËΩ¨Êç¢ËøáÁ®ã‰∏≠Âá∫Áé∞ÈîôËØØÔºåËØ∑ÈáçËØïÔºÅ',
                recognized_text: '--- ËØÜÂà´ÁöÑÊñáÂ≠ó ---',
                no_text_found: '--- Êú™ËØÜÂà´Âà∞ÊñáÂ≠ó ---',
                text_recognition_failed: '--- ÊñáÂ≠óËØÜÂà´Â§±Ë¥• ---',
                image_to_ascii: '--- ÂõæÂÉèËΩ¨ASCII ---',
                width_adjusted: 'Êô∫ËÉΩË∞ÉÊï¥ÂÆΩÂ∫¶',
                image_size: 'ÂõæÁâáÂ∞∫ÂØ∏',
                no_image_selected: 'ËØ∑ÂÖà‰∏ä‰º†ÂõæÁâá',
                download_image: 'üñºÔ∏è ‰∏ãËΩΩÂõæÁâá',
                text_result: 'ÊñáÂ≠óÁâà',
                image_result: 'ÂõæÁâáÁâà'
            },
            en: {
                title: 'üé® Smart ASCII Art',
                subtitle: 'Smart ASCII Art Generator - Text Recognition & Image Outline',
                upload_title: 'Select or Drag Image',
                upload_desc: 'Supports PNG, JPEG formats',
                select_image: 'Select Image',
                preview_title: 'Image Preview',
                ascii_width: 'ASCII Width:',
                edge_sensitivity: 'Edge Sensitivity:',
                noise_filter: 'Noise Filter:',
                invert_colors: 'Invert Colors',
                enable_ocr: 'Enable Text Recognition (OCR)',
                auto_optimize: 'Auto Optimize Parameters',
                convert_button: 'üéØ Smart Convert ASCII',
                processing: 'Processing image...',
                result_title: 'ASCII Art Result',
                copy_result: 'üìã Copy Result',
                download_txt: 'üíæ Download txt',
                reset: 'üîÑ Reset',
                footer: 'Smart ASCII Art Generator - Text Recognition & Image Outline | Pure Frontend',
                analyzing_image: 'Analyzing image features...',
                recognizing_text: 'Recognizing text...',
                generating_ascii: 'Generating ASCII art...',
                copy_success: '‚úÖ Copied to clipboard',
                copy_failed: 'Copy failed, please select text manually',
                invalid_file: 'Please select a valid PNG or JPEG image file!',
                conversion_error: 'An error occurred during conversion, please try again!',
                recognized_text: '--- Recognized Text ---',
                no_text_found: '--- No Text Found ---',
                text_recognition_failed: '--- Text Recognition Failed ---',
                image_to_ascii: '--- Image to ASCII ---',
                width_adjusted: 'Width Auto-Adjusted',
                image_size: 'Image Size',
                no_image_selected: 'Please upload an image first',
                download_image: 'üñºÔ∏è Download Image',
                text_result: 'Text Version',
                image_result: 'Image Version'
            },
            ja: {
                title: 'üé® „Çπ„Éû„Éº„ÉàASCII„Ç¢„Éº„Éà',
                subtitle: '„Çπ„Éû„Éº„ÉàASCII„Ç¢„Éº„ÉàÁîüÊàêÂô® - „ÉÜ„Ç≠„Çπ„ÉàË™çË≠ò„Å®ÁîªÂÉèËº™ÈÉ≠',
                upload_title: 'ÁîªÂÉè„ÇíÈÅ∏Êäû„Åæ„Åü„ÅØ„Éâ„É©„ÉÉ„Ç∞',
                upload_desc: 'PNG„ÄÅJPEGÂΩ¢Âºè„Çí„Çµ„Éù„Éº„Éà',
                select_image: 'ÁîªÂÉè„ÇíÈÅ∏Êäû',
                preview_title: 'ÁîªÂÉè„Éó„É¨„Éì„É•„Éº',
                ascii_width: 'ASCIIÂπÖ:',
                edge_sensitivity: '„Ç®„ÉÉ„Ç∏ÊÑüÂ∫¶:',
                noise_filter: '„Éé„Ç§„Ç∫„Éï„Ç£„É´„Çø„Éº:',
                invert_colors: 'Ëâ≤„ÇíÂèçËª¢',
                enable_ocr: '„ÉÜ„Ç≠„Çπ„ÉàË™çË≠ò„ÇíÊúâÂäπ„Å´„Åô„Çã (OCR)',
                auto_optimize: '„Éë„É©„É°„Éº„Çø„ÇíËá™ÂãïÊúÄÈÅ©Âåñ',
                convert_button: 'üéØ „Çπ„Éû„Éº„ÉàÂ§âÊèõASCII',
                processing: 'ÁîªÂÉè„ÇíÂá¶ÁêÜ‰∏≠...',
                result_title: 'ASCII„Ç¢„Éº„ÉàÁµêÊûú',
                copy_result: 'üìã ÁµêÊûú„Çí„Ç≥„Éî„Éº',
                download_txt: 'üíæ txt„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ',
                reset: 'üîÑ „É™„Çª„ÉÉ„Éà',
                footer: '„Çπ„Éû„Éº„ÉàASCII„Ç¢„Éº„ÉàÁîüÊàêÂô® - „ÉÜ„Ç≠„Çπ„ÉàË™çË≠ò„Å®ÁîªÂÉèËº™ÈÉ≠ | Á¥îÁ≤ã„Å™„Éï„É≠„É≥„Éà„Ç®„É≥„Éâ',
                analyzing_image: 'ÁîªÂÉèÁâπÂæ¥„ÇíÂàÜÊûê‰∏≠...',
                recognizing_text: '„ÉÜ„Ç≠„Çπ„Éà„ÇíË™çË≠ò‰∏≠...',
                generating_ascii: 'ASCII„Ç¢„Éº„Éà„ÇíÁîüÊàê‰∏≠...',
                copy_success: '‚úÖ „ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü',
                copy_failed: '„Ç≥„Éî„Éº„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÊâãÂãï„Åß„ÉÜ„Ç≠„Çπ„Éà„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
                invalid_file: 'ÊúâÂäπ„Å™PNG„Åæ„Åü„ÅØJPEGÁîªÂÉè„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅ',
                conversion_error: 'Â§âÊèõ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇÂÜçË©¶Ë°å„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅ',
                recognized_text: '--- Ë™çË≠ò„Åï„Çå„Åü„ÉÜ„Ç≠„Çπ„Éà ---',
                no_text_found: '--- „ÉÜ„Ç≠„Çπ„Éà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì ---',
                text_recognition_failed: '--- „ÉÜ„Ç≠„Çπ„ÉàË™çË≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü ---',
                image_to_ascii: '--- ÁîªÂÉè„Åã„ÇâASCII„Å∏ ---',
                width_adjusted: 'ÂπÖ„ÇíËá™ÂãïË™øÊï¥',
                image_size: 'ÁîªÂÉè„Çµ„Ç§„Ç∫',
                no_image_selected: '„Åæ„ÅöÁîªÂÉè„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
                download_image: 'üñºÔ∏è ÁîªÂÉè„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ',
                text_result: '„ÉÜ„Ç≠„Çπ„ÉàÁâà',
                image_result: 'ÁîªÂÉèÁâà'
            }
        };
    }

    t(key) {
        return this.translations[this.currentLang][key] || key;
    }

    setLanguage(lang) {
        this.currentLang = lang;
        localStorage.setItem('preferred-language', lang);
        this.updateUI();
    }

    updateUI() {
        document.querySelectorAll('[data-i18n]').forEach(element => {
            const key = element.getAttribute('data-i18n');
            element.textContent = this.t(key);
        });

        // Êõ¥Êñ∞ËØ≠Ë®ÄÊåâÈíÆÁä∂ÊÄÅ
        document.querySelectorAll('.lang-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`lang${this.currentLang.charAt(0).toUpperCase() + this.currentLang.slice(1)}`).classList.add('active');
    }
}

class OutlineASCIIConverter {
    constructor() {
        this.currentImage = null;
        this.i18n = new I18n();
        this.initializeElements();
        this.bindEvents();
        this.i18n.updateUI();
    }

    initializeElements() {
        // Ëé∑ÂèñDOMÂÖÉÁ¥†
        this.uploadArea = document.getElementById('uploadArea');
        this.imageInput = document.getElementById('imageInput');
        this.selectButton = document.getElementById('selectButton');
        this.previewSection = document.getElementById('previewSection');
        this.previewImage = document.getElementById('previewImage');
        this.loadingSection = document.getElementById('loadingSection');
        this.loadingText = document.getElementById('loadingText');
        this.resultSection = document.getElementById('resultSection');
        this.asciiOutput = document.getElementById('asciiOutput');
        this.convertButton = document.getElementById('convertButton');
        this.copyButton = document.getElementById('copyButton');
        this.downloadButton = document.getElementById('downloadButton');
        this.resetButton = document.getElementById('resetButton');
        this.downloadImageButton = document.getElementById('downloadImageButton');
        this.textTab = document.getElementById('textTab');
        this.imageTab = document.getElementById('imageTab');
        this.textResult = document.getElementById('textResult');
        this.imageResult = document.getElementById('imageResult');
        this.asciiCanvas = document.getElementById('asciiCanvas');
        this.placeholderPreview = document.getElementById('placeholderPreview');
        
        // Êñ∞ÁöÑÊéßÂà∂ÂÖÉÁ¥†
        this.asciiWidth = document.getElementById('asciiWidth');
        this.widthValue = document.getElementById('widthValue');
        this.edgeThreshold = document.getElementById('edgeThreshold');
        this.thresholdValue = document.getElementById('thresholdValue');
        this.noiseReduction = document.getElementById('noiseReduction');
        this.noiseValue = document.getElementById('noiseValue');
        this.invertColors = document.getElementById('invertColors');
        this.enableOCR = document.getElementById('enableOCR');
        this.autoOptimize = document.getElementById('autoOptimize');
    }

    bindEvents() {
        // Êñá‰ª∂ÈÄâÊã©‰∫ã‰ª∂
        this.selectButton.addEventListener('click', () => this.imageInput.click());
        this.imageInput.addEventListener('change', (e) => this.handleFileSelect(e));

        // ÊãñÊãΩ‰∫ã‰ª∂
        this.uploadArea.addEventListener('dragover', (e) => this.handleDragOver(e));
        this.uploadArea.addEventListener('dragleave', (e) => this.handleDragLeave(e));
        this.uploadArea.addEventListener('drop', (e) => this.handleDrop(e));

        // ËΩ¨Êç¢ÊåâÈíÆ
        this.convertButton.addEventListener('click', () => this.convertToASCII());

        // ÊéßÂà∂ÊåâÈíÆ
        this.copyButton.addEventListener('click', () => this.copyResult());
        this.downloadButton.addEventListener('click', () => this.downloadResult());
        this.downloadImageButton.addEventListener('click', () => this.downloadImageResult());
        this.resetButton.addEventListener('click', () => this.reset());
        
        // TabÂàáÊç¢
        this.textTab.addEventListener('click', () => this.switchTab('text'));
        this.imageTab.addEventListener('click', () => this.switchTab('image'));

        // ÊéßÂà∂ÊªëÂùó
        this.asciiWidth.addEventListener('input', (e) => {
            this.widthValue.textContent = e.target.value;
        });
        
        this.edgeThreshold.addEventListener('input', (e) => {
            this.thresholdValue.textContent = e.target.value;
        });
        
        this.noiseReduction.addEventListener('input', (e) => {
            this.noiseValue.textContent = e.target.value;
        });

        // ËØ≠Ë®ÄÂàáÊç¢‰∫ã‰ª∂
        document.getElementById('langZh').addEventListener('click', () => this.i18n.setLanguage('zh'));
        document.getElementById('langEn').addEventListener('click', () => this.i18n.setLanguage('en'));
        document.getElementById('langJa').addEventListener('click', () => this.i18n.setLanguage('ja'));
    }

    handleDragOver(e) {
        e.preventDefault();
        this.uploadArea.classList.add('dragover');
    }

    handleDragLeave(e) {
        e.preventDefault();
        this.uploadArea.classList.remove('dragover');
    }

    handleDrop(e) {
        e.preventDefault();
        this.uploadArea.classList.remove('dragover');
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            this.processFile(files[0]);
        }
    }

    handleFileSelect(e) {
        const file = e.target.files[0];
        if (file) {
            this.processFile(file);
        }
    }

    processFile(file) {
        if (!this.isValidImageFile(file)) {
            alert(this.i18n.t('invalid_file'));
            return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
            this.currentImage = new Image();
            this.currentImage.onload = () => {
                this.showPreview(e.target.result);
            };
            this.currentImage.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    isValidImageFile(file) {
        const validTypes = ['image/png', 'image/jpeg', 'image/jpg'];
        return validTypes.includes(file.type);
    }

    showPreview(imageSrc) {
        this.previewImage.src = imageSrc;
        this.previewImage.style.display = 'block';
        this.placeholderPreview.style.display = 'none';
        this.resultSection.style.display = 'none';
        
        // Ê†πÊçÆÂõæÁâáÂ§ßÂ∞èÊô∫ËÉΩË∞ÉÊï¥ASCIIÂÆΩÂ∫¶
        this.adjustASCIIWidthByImageSize();
        
        // Ëá™Âä®ÂºÄÂßãËΩ¨Êç¢ASCII
        this.autoConvertToASCII();
    }

    async autoConvertToASCII() {
        // Âª∂Ëøü‰∏ÄÁßíÂêéËá™Âä®ÂºÄÂßãËΩ¨Êç¢ÔºåËÆ©Áî®Êà∑ÁúãÂà∞Ë∞ÉÊï¥ÊèêÁ§∫
        setTimeout(async () => {
            await this.convertToASCII();
        }, 1000);
    }

    adjustASCIIWidthByImageSize() {
        if (!this.currentImage) return;
        
        const imageWidth = this.currentImage.naturalWidth;
        const imageHeight = this.currentImage.naturalHeight;
        
        // ËÆ°ÁÆóÂª∫ËÆÆÁöÑASCIIÂÆΩÂ∫¶
        let suggestedWidth;
        
        if (imageWidth <= 400) {
            // Â∞èÂõæÁâáÔºö‰ΩøÁî®ËæÉÂ∞èÁöÑASCIIÂÆΩÂ∫¶
            suggestedWidth = 80;
        } else if (imageWidth <= 800) {
            // ‰∏≠Á≠âÂõæÁâáÔºö‰ΩøÁî®‰∏≠Á≠âASCIIÂÆΩÂ∫¶
            suggestedWidth = 150;
        } else if (imageWidth <= 1200) {
            // Â§ßÂõæÁâáÔºö‰ΩøÁî®ËæÉÂ§ßASCIIÂÆΩÂ∫¶
            suggestedWidth = 220;
        } else if (imageWidth <= 2000) {
            // Ë∂ÖÂ§ßÂõæÁâáÔºö‰ΩøÁî®ÂæàÂ§ßASCIIÂÆΩÂ∫¶
            suggestedWidth = 300;
        } else {
            // ÊûÅÂ§ßÂõæÁâáÔºö‰ΩøÁî®ÊúÄÂ§ßASCIIÂÆΩÂ∫¶
            suggestedWidth = 360;
        }
        
        // ËÄÉËôëÂõæÁâáÁöÑÂÆΩÈ´òÊØî
        const aspectRatio = imageWidth / imageHeight;
        if (aspectRatio > 2) {
            // ÂÆΩÂõæÁâáÔºöÂ¢ûÂä†ÂÆΩÂ∫¶
            suggestedWidth = Math.min(360, Math.round(suggestedWidth * 1.2));
        } else if (aspectRatio < 0.5) {
            // È´òÂõæÁâáÔºöÂáèÂ∞ëÂÆΩÂ∫¶
            suggestedWidth = Math.max(80, Math.round(suggestedWidth * 0.8));
        }
        
        // Êõ¥Êñ∞UI
        this.asciiWidth.value = suggestedWidth;
        this.widthValue.textContent = suggestedWidth;
        
        // ÊòæÁ§∫Êô∫ËÉΩË∞ÉÊï¥ÊèêÁ§∫
        this.showWidthAdjustmentNotice(imageWidth, imageHeight, suggestedWidth);
    }

    showWidthAdjustmentNotice(imageWidth, imageHeight, suggestedWidth) {
        // ÂàõÂª∫‰∏¥Êó∂ÊèêÁ§∫‰ø°ÊÅØ
        const notice = document.createElement('div');
        notice.className = 'width-adjustment-notice';
        notice.innerHTML = `
            <div class="notice-content">
                <span class="notice-icon">üéØ</span>
                <span class="notice-text">${this.i18n.t('width_adjusted')}: ${suggestedWidth}</span>
                <span class="notice-detail">${this.i18n.t('image_size')}: ${imageWidth}√ó${imageHeight}</span>
            </div>
        `;
        
        document.body.appendChild(notice);
        
        // 3ÁßíÂêéËá™Âä®ÁßªÈô§
        setTimeout(() => {
            if (document.body.contains(notice)) {
                document.body.removeChild(notice);
            }
        }, 3000);
    }

    showLoading(message = null) {
        this.loadingText.textContent = message || this.i18n.t('processing');
        this.loadingSection.style.display = 'block';
        // ‰øùÊåÅÈ¢ÑËßàÂå∫ÂüüÂßãÁªàÂèØËßÅ
        // this.previewSection.style.display = 'none';
        this.resultSection.style.display = 'none';
    }

    hideLoading() {
        this.loadingSection.style.display = 'none';
    }

    async convertToASCII() {
        if (!this.currentImage) return;

        try {
            // ÂàõÂª∫canvasÂ§ÑÁêÜÂõæÁâá
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            const targetWidth = parseInt(this.asciiWidth.value);
            const aspectRatio = this.currentImage.height / this.currentImage.width;
            const targetHeight = Math.floor(targetWidth * aspectRatio * 0.5);

            canvas.width = targetWidth;
            canvas.height = targetHeight;
            
            ctx.drawImage(this.currentImage, 0, 0, targetWidth, targetHeight);
            
            // Ëé∑ÂèñÂõæÂÉèÊï∞ÊçÆ
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            let bestParams = {
                edgeThreshold: parseInt(this.edgeThreshold.value),
                noiseReduction: parseInt(this.noiseReduction.value)
            };
            
            // Â¶ÇÊûúÂêØÁî®Ëá™Âä®‰ºòÂåñÔºåÂØªÊâæÊúÄ‰Ω≥ÂèÇÊï∞
            if (this.autoOptimize.checked) {
                this.showLoading(this.i18n.t('analyzing_image'));
                bestParams = await this.findOptimalParameters(imageData, canvas.width, canvas.height);
                
                // Êõ¥Êñ∞UIÊòæÁ§∫ÊúÄ‰Ω≥ÂèÇÊï∞
                this.edgeThreshold.value = bestParams.edgeThreshold;
                this.thresholdValue.textContent = bestParams.edgeThreshold;
                this.noiseReduction.value = bestParams.noiseReduction;
                this.noiseValue.textContent = bestParams.noiseReduction;
            }
            
            let asciiResult = '';

            // Â¶ÇÊûúÂêØÁî®OCRÔºåÂÖàËøõË°åÊñáÂ≠óËØÜÂà´
            if (this.enableOCR.checked) {
                this.showLoading(this.i18n.t('recognizing_text'));
                const ocrResult = await this.performOCR(canvas);
                asciiResult += ocrResult;
                asciiResult += `\n${this.i18n.t('image_to_ascii')}\n\n`;
            }

            this.showLoading(this.i18n.t('generating_ascii'));
            
            // ‰ΩøÁî®ÂéüÂßãÁÆóÊ≥ïÁîüÊàêÂõæÂÉèASCIIÔºàÊõ¥Êé•ËøëÂéüÂõæÔºâ
            const imageASCII = this.generateOriginalStyleASCII(imageData, canvas.width, canvas.height, bestParams);
            asciiResult += imageASCII;
            
            this.showResult(asciiResult);

        } catch (error) {
            console.error('ËΩ¨Êç¢Â§±Ë¥•:', error);
            alert(this.i18n.t('conversion_error'));
            this.hideLoading();
        }
    }


    applyGaussianBlur(data, width, height, radius) {
        const output = new Uint8ClampedArray(data);
        const kernel = this.generateGaussianKernel(radius);
        const kernelSize = kernel.length;
        const half = Math.floor(kernelSize / 2);
        
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                let sum = 0;
                let weightSum = 0;
                
                for (let ky = -half; ky <= half; ky++) {
                    for (let kx = -half; kx <= half; kx++) {
                        const px = Math.max(0, Math.min(width - 1, x + kx));
                        const py = Math.max(0, Math.min(height - 1, y + ky));
                        const weight = kernel[ky + half][kx + half];
                        
                        sum += data[(py * width + px) * 4] * weight;
                        weightSum += weight;
                    }
                }
                
                const index = (y * width + x) * 4;
                const blurred = Math.round(sum / weightSum);
                output[index] = blurred;
                output[index + 1] = blurred;
                output[index + 2] = blurred;
            }
        }
        
        data.set(output);
    }

    generateGaussianKernel(radius) {
        const size = radius * 2 + 1;
        const kernel = [];
        const sigma = radius / 3;
        const sigma2 = 2 * sigma * sigma;
        const sqrtPi2Sigma = Math.sqrt(2 * Math.PI) * sigma;
        
        for (let y = 0; y < size; y++) {
            kernel[y] = [];
            for (let x = 0; x < size; x++) {
                const dx = x - radius;
                const dy = y - radius;
                const distance2 = dx * dx + dy * dy;
                kernel[y][x] = Math.exp(-distance2 / sigma2) / sqrtPi2Sigma;
            }
        }
        
        return kernel;
    }


    // Ëá™Âä®ÂØªÊâæÊúÄ‰Ω≥ÂèÇÊï∞
    async findOptimalParameters(imageData, width, height) {
        const data = new Uint8ClampedArray(imageData.data);
        
        // ÂàÜÊûêÂõæÂÉèÁâπÂæÅ
        const imageStats = this.analyzeImageFeatures(data, width, height);
        
        // Âü∫‰∫éÂõæÂÉèÁâπÂæÅÁ°ÆÂÆöÊúÄ‰Ω≥ÂèÇÊï∞
        let bestEdgeThreshold, bestNoiseReduction;
        
        // Ê†πÊçÆÂõæÂÉèÂØπÊØîÂ∫¶Ë∞ÉÊï¥ËæπÁºòÊ£ÄÊµãÈòàÂÄº
        if (imageStats.contrast < 0.3) {
            bestEdgeThreshold = 60; // ‰ΩéÂØπÊØîÂ∫¶ÂõæÂÉè‰ΩøÁî®ËæÉ‰ΩéÈòàÂÄº
        } else if (imageStats.contrast > 0.7) {
            bestEdgeThreshold = 120; // È´òÂØπÊØîÂ∫¶ÂõæÂÉè‰ΩøÁî®ËæÉÈ´òÈòàÂÄº
        } else {
            bestEdgeThreshold = 80; // ‰∏≠Á≠âÂØπÊØîÂ∫¶‰ΩøÁî®ÈªòËÆ§ÂÄº
        }
        
        // Ê†πÊçÆÂõæÂÉèÂô™Èü≥Ê∞¥Âπ≥Ë∞ÉÊï¥ËøáÊª§Âº∫Â∫¶
        if (imageStats.noiseLevel > 0.6) {
            bestNoiseReduction = 5; // È´òÂô™Èü≥ÂõæÂÉèÈúÄË¶ÅÊõ¥Âº∫ËøáÊª§
        } else if (imageStats.noiseLevel < 0.3) {
            bestNoiseReduction = 1; // ‰ΩéÂô™Èü≥ÂõæÂÉè‰ΩøÁî®ËΩªÂæÆËøáÊª§
        } else {
            bestNoiseReduction = 3; // ‰∏≠Á≠âÂô™Èü≥‰ΩøÁî®ÈªòËÆ§ÂÄº
        }
        
        return {
            edgeThreshold: bestEdgeThreshold,
            noiseReduction: bestNoiseReduction
        };
    }

    // ÂàÜÊûêÂõæÂÉèÁâπÂæÅ
    analyzeImageFeatures(data, width, height) {
        let totalBrightness = 0;
        let minBrightness = 255;
        let maxBrightness = 0;
        let gradientSum = 0;
        let totalPixels = width * height;
        
        // ËΩ¨Êç¢‰∏∫ÁÅ∞Â∫¶Âπ∂ËÆ°ÁÆóÁªüËÆ°‰ø°ÊÅØ
        const grayData = new Uint8ClampedArray(totalPixels);
        for (let i = 0; i < data.length; i += 4) {
            const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
            const pixelIndex = i / 4;
            grayData[pixelIndex] = gray;
            
            totalBrightness += gray;
            minBrightness = Math.min(minBrightness, gray);
            maxBrightness = Math.max(maxBrightness, gray);
        }
        
        // ËÆ°ÁÆóÂØπÊØîÂ∫¶
        const avgBrightness = totalBrightness / totalPixels;
        const contrast = (maxBrightness - minBrightness) / 255;
        
        // ËÆ°ÁÆóÂô™Èü≥Ê∞¥Âπ≥ÔºàÈÄöËøáÂ±ÄÈÉ®Ê¢ØÂ∫¶ÂèòÂåñÔºâ
        for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
                const center = grayData[y * width + x];
                const neighbors = [
                    grayData[(y-1) * width + x],
                    grayData[(y+1) * width + x],
                    grayData[y * width + (x-1)],
                    grayData[y * width + (x+1)]
                ];
                
                let localVariance = 0;
                neighbors.forEach(neighbor => {
                    localVariance += Math.pow(neighbor - center, 2);
                });
                gradientSum += Math.sqrt(localVariance / 4);
            }
        }
        
        const noiseLevel = (gradientSum / (totalPixels * 255)) * 2; // ÂΩí‰∏ÄÂåñÂô™Èü≥Ê∞¥Âπ≥
        
        return {
            avgBrightness: avgBrightness / 255,
            contrast: contrast,
            noiseLevel: Math.min(noiseLevel, 1) // ÈôêÂà∂Âú®0-1ËåÉÂõ¥
        };
    }

    // ‰ºòÂåñÁöÑASCIIÁîüÊàêÁÆóÊ≥ï
    generateOptimizedASCII(imageData, width, height, params) {
        const data = new Uint8ClampedArray(imageData.data);
        
        // È¢ÑÂ§ÑÁêÜÂõæÂÉè
        const processedData = this.preprocessImageWithParams(data, width, height, params.noiseReduction);
        
        // Ê£ÄÊµãËæπÁºò
        const edgeData = this.detectEdgesWithParams(processedData, width, height, params.edgeThreshold);
        
        // ÁîüÊàêÊõ¥Â•ΩÁöÑASCIIËâ∫ÊúØ
        return this.generateEnhancedASCII(processedData, edgeData, width, height);
    }

    // Â∏¶ÂèÇÊï∞ÁöÑÈ¢ÑÂ§ÑÁêÜ
    preprocessImageWithParams(data, width, height, noiseLevel) {
        // ËΩ¨Êç¢‰∏∫ÁÅ∞Â∫¶Âõæ
        for (let i = 0; i < data.length; i += 4) {
            const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
            data[i] = gray;     // R
            data[i + 1] = gray; // G
            data[i + 2] = gray; // B
        }
        
        // Â∫îÁî®ÈÄÇÂ∫¶ÁöÑÈ´òÊñØÊ®°Á≥ä
        if (noiseLevel > 0) {
            this.applyGaussianBlur(data, width, height, noiseLevel);
        }
        
        return data;
    }

    // Â∏¶ÂèÇÊï∞ÁöÑËæπÁºòÊ£ÄÊµã
    detectEdgesWithParams(data, width, height, threshold) {
        const edges = new Uint8ClampedArray(width * height);
        
        // SobelËæπÁºòÊ£ÄÊµã
        const sobelX = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];
        const sobelY = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];
        
        for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
                let gx = 0, gy = 0;
                
                for (let ky = -1; ky <= 1; ky++) {
                    for (let kx = -1; kx <= 1; kx++) {
                        const pixel = data[((y + ky) * width + (x + kx)) * 4];
                        gx += pixel * sobelX[ky + 1][kx + 1];
                        gy += pixel * sobelY[ky + 1][kx + 1];
                    }
                }
                
                const magnitude = Math.sqrt(gx * gx + gy * gy);
                edges[y * width + x] = magnitude > threshold ? 255 : 0;
            }
        }
        
        return edges;
    }

    // Â¢ûÂº∫ÁöÑASCIIÁîüÊàêÁÆóÊ≥ï
    generateEnhancedASCII(grayData, edgeData, width, height) {
        // ‰ºòÂåñÁöÑÂ≠óÁ¨¶ÈõÜ - Êõ¥Â•ΩÁöÑÊ∏êÂèòÊïàÊûú
        const chars = ' .\'`^",:;Il!i><~+_-?][}{1)(|\\/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$';
        const edgeChars = '‚ñà‚ñâ‚ñä‚ñã‚ñå‚ñç‚ñé‚ñè';
        const invert = this.invertColors.checked;
        
        let ascii = '';
        
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const pixelIndex = y * width + x;
                const grayValue = grayData[pixelIndex * 4];
                const edgeValue = edgeData[pixelIndex];
                
                let char;
                
                if (edgeValue > 128) {
                    // Âº∫ËæπÁºòÂå∫Âüü‰ΩøÁî®ËæπÁºòÂ≠óÁ¨¶
                    const intensity = edgeValue / 255;
                    const charIndex = Math.floor(intensity * (edgeChars.length - 1));
                    char = edgeChars[invert ? edgeChars.length - 1 - charIndex : charIndex];
                } else {
                    // ÈùûËæπÁºòÂå∫Âüü‰ΩøÁî®ÁÅ∞Â∫¶Êò†Â∞Ñ
                    const intensity = grayValue / 255;
                    const charIndex = Math.floor(intensity * (chars.length - 1));
                    char = chars[invert ? chars.length - 1 - charIndex : charIndex];
                }
                
                ascii += char;
            }
            ascii += '\n';
        }
        
        return ascii;
    }

    // OCRÊñáÂ≠óËØÜÂà´ÂäüËÉΩ
    async performOCR(canvas) {
        try {
            const { data: { text } } = await Tesseract.recognize(
                canvas,
                'chi_sim+chi_tra+jpn+eng', // ÊîØÊåÅ‰∏≠ÊñáÁÆÄ‰Ωì„ÄÅÁπÅ‰Ωì„ÄÅÊó•Êñá„ÄÅËã±Êñá
                {
                    logger: m => {
                        if (m.status === 'recognizing text') {
                            const progress = Math.round(m.progress * 100);
                            this.showLoading(`${this.i18n.t('recognizing_text')} ${progress}%`);
                        }
                    }
                }
            );

            if (text.trim()) {
                return `${this.i18n.t('recognized_text')}\n${text.trim()}\n`;
            } else {
                return `${this.i18n.t('no_text_found')}\n`;
            }
        } catch (error) {
            console.error('OCRËØÜÂà´Â§±Ë¥•:', error);
            return `${this.i18n.t('text_recognition_failed')}\n`;
        }
    }

    // ÂéüÂßãÈ£éÊ†ºÁöÑASCIIËΩ¨Êç¢ÁÆóÊ≥ïÔºàÊõ¥Êé•ËøëÂéüÂõæÔºâ
    generateOriginalStyleASCII(imageData, width, height, params) {
        const data = new Uint8ClampedArray(imageData.data);
        
        // È¢ÑÂ§ÑÁêÜÂõæÂÉè
        const processedData = this.preprocessImageWithParams(data, width, height, params.noiseReduction);
        
        // ‰ΩøÁî®ÂéüÂßãÁöÑÂü∫‰∫éÁÅ∞Â∫¶ÁöÑÂ≠óÁ¨¶Êò†Â∞ÑÊñπÊ≥ï
        return this.imageToASCIIOriginal(processedData, width, height);
    }

    // ÂéüÂßãÁöÑÂõæÂÉèËΩ¨ASCIIÁÆóÊ≥ï
    imageToASCIIOriginal(data, width, height) {
        // ‰ΩøÁî®ÂéüÂßãÁöÑASCIIÂ≠óÁ¨¶ÈõÜÔºå‰ªéÊöóÂà∞‰∫ÆÔºåÊïàÊûúÊõ¥Êé•ËøëÂéüÂõæ
        const asciiChars = '@%#*+=-:. ';
        const invert = this.invertColors.checked;
        
        let ascii = '';
        
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const i = (y * width + x) * 4;
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // ËÆ°ÁÆóÁÅ∞Â∫¶ÂÄº
                const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
                
                // Â∞ÜÁÅ∞Â∫¶ÂÄºÊò†Â∞ÑÂà∞ASCIIÂ≠óÁ¨¶
                const charIndex = Math.floor((gray / 255) * (asciiChars.length - 1));
                const selectedChar = asciiChars[invert ? asciiChars.length - 1 - charIndex : charIndex];
                
                ascii += selectedChar;
            }
            ascii += '\n';
        }
        
        return ascii;
    }

    showResult(asciiArt) {
        this.asciiOutput.textContent = asciiArt;
        
        // ÁîüÊàêASCIIÂõæÁâáÁâàÊú¨
        this.generateASCIIImage(asciiArt);
        
        this.hideLoading();
        this.resultSection.style.display = 'block';
    }

    generateASCIIImage(asciiText) {
        const canvas = this.asciiCanvas;
        const ctx = canvas.getContext('2d');
        
        // ËÆæÁΩÆÂ≠ó‰ΩìÂíåÊ†∑Âºè
        const fontSize = 8;
        const lineHeight = fontSize * 1.1;
        ctx.font = `${fontSize}px "Courier New", monospace`;
        ctx.textBaseline = 'top';
        
        // ËÆ°ÁÆóÁîªÂ∏ÉÂ∞∫ÂØ∏
        const lines = asciiText.split('\n');
        const maxLineLength = Math.max(...lines.map(line => line.length));
        const canvasWidth = maxLineLength * fontSize * 0.6; // Â≠óÁ¨¶ÂÆΩÂ∫¶Á∫¶‰∏∫Â≠ó‰ΩìÂ§ßÂ∞èÁöÑ0.6ÂÄç
        const canvasHeight = lines.length * lineHeight;
        
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        
        // ËÆæÁΩÆËÉåÊôØËâ≤‰∏∫ÁôΩËâ≤
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // ËÆæÁΩÆÊñáÂ≠óÈ¢úËâ≤‰∏∫ÈªëËâ≤
        ctx.fillStyle = '#000000';
        
        // ÁªòÂà∂ASCIIÊñáÂ≠ó
        lines.forEach((line, index) => {
            const y = index * lineHeight;
            ctx.fillText(line, 0, y);
        });
    }

    switchTab(tabType) {
        if (tabType === 'text') {
            this.textTab.classList.add('active');
            this.imageTab.classList.remove('active');
            this.textResult.style.display = 'block';
            this.imageResult.style.display = 'none';
        } else {
            this.imageTab.classList.add('active');
            this.textTab.classList.remove('active');
            this.textResult.style.display = 'none';
            this.imageResult.style.display = 'block';
        }
    }

    downloadImageResult() {
        const canvas = this.asciiCanvas;
        const link = document.createElement('a');
        link.download = 'ascii-art.png';
        link.href = canvas.toDataURL();
        link.click();
    }

    copyResult() {
        const text = this.asciiOutput.textContent;
        navigator.clipboard.writeText(text).then(() => {
            this.showCopySuccess();
        }).catch(err => {
            console.error('Â§çÂà∂Â§±Ë¥•:', err);
            this.fallbackCopy(text);
        });
    }

    fallbackCopy(text) {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        try {
            document.execCommand('copy');
            this.showCopySuccess();
        } catch (err) {
            alert(this.i18n.t('copy_failed'));
        }
        document.body.removeChild(textArea);
    }

    showCopySuccess() {
        const notification = document.createElement('div');
        notification.className = 'copy-success';
        notification.textContent = this.i18n.t('copy_success');
        document.body.appendChild(notification);

        setTimeout(() => {
            document.body.removeChild(notification);
        }, 2000);
    }

    downloadResult() {
        const text = this.asciiOutput.textContent;
        const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = 'outline-ascii-art.txt';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        URL.revokeObjectURL(url);
    }

    reset() {
        // ÈáçÁΩÆÁªìÊûúÂå∫Âüü
        this.loadingSection.style.display = 'none';
        this.resultSection.style.display = 'none';
        this.asciiOutput.textContent = '';
        
        // Ê∏ÖÁ©∫canvas
        if (this.asciiCanvas) {
            const ctx = this.asciiCanvas.getContext('2d');
            ctx.clearRect(0, 0, this.asciiCanvas.width, this.asciiCanvas.height);
        }
        
        // ÂàáÊç¢ÂõûÊñáÂ≠óÁâàtab
        this.switchTab('text');
        
        // Á°Æ‰øùÈ¢ÑËßàÂå∫ÂüüÂßãÁªàÂèØËßÅ
        this.previewSection.style.display = 'block';
        
        // Â¶ÇÊûúÊúâÂõæÁâáÔºåÁ°Æ‰øùÈ¢ÑËßàÂõæÁâáÊòæÁ§∫ÔºåÈöêËóèÂç†‰ΩçÁ¨¶
        if (this.currentImage && this.previewImage.src) {
            this.previewImage.style.display = 'block';
            this.placeholderPreview.style.display = 'none';
        } else {
            // Â¶ÇÊûúÊ≤°ÊúâÂõæÁâáÔºåÊòæÁ§∫Âç†‰ΩçÁ¨¶
            this.previewImage.style.display = 'none';
            this.placeholderPreview.style.display = 'block';
        }
        
        // ‰∏çÈáçÁΩÆÂèÇÊï∞ÔºåËÆ©Áî®Êà∑‰øùÊåÅÂΩìÂâçË∞ÉÊï¥ÁöÑËÆæÁΩÆ
    }
}

// È°µÈù¢Âä†ËΩΩÂÆåÊàêÂêéÂàùÂßãÂåñ
document.addEventListener('DOMContentLoaded', () => {
    new OutlineASCIIConverter();
});

// Èò≤Ê≠¢È°µÈù¢ÊÑèÂ§ñÂÖ≥Èó≠Êó∂‰∏¢Â§±ËøõÂ∫¶
window.addEventListener('beforeunload', (e) => {
    const loadingSection = document.getElementById('loadingSection');
    if (loadingSection && loadingSection.style.display !== 'none') {
        e.preventDefault();
        e.returnValue = 'Ê≠£Âú®Â§ÑÁêÜ‰∏≠ÔºåÁ°ÆÂÆöË¶ÅÁ¶ªÂºÄÂêóÔºü';
    }
});